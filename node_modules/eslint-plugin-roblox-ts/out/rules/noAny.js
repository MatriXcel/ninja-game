"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.noAny = exports.noAnyName = void 0;
const typescript_1 = __importDefault(require("typescript"));
const rules_1 = require("../util/rules");
const traversal_1 = require("../util/traversal");
const types_1 = require("../util/types");
exports.noAnyName = "no-any";
exports.noAny = rules_1.makeRule({
    name: exports.noAnyName,
    meta: {
        type: "problem",
        docs: {
            description: "Bans prototype from being used",
            category: "Possible Errors",
            recommended: "error",
            requiresTypeChecking: true,
        },
        messages: {
            anyViolation: "Using values of type `any` is not supported! Use `unknown` instead.",
        },
        schema: [],
    },
    defaultOptions: [],
    create(context) {
        const service = rules_1.getParserServices(context);
        const checker = service.program.getTypeChecker();
        function validateNotAnyType(esNode, tsNode) {
            if (typescript_1.default.isSpreadElement(tsNode)) {
                tsNode = traversal_1.skipDownwards(tsNode.expression);
            }
            let type = types_1.getType(checker, tsNode);
            if (types_1.isDefinitelyType(type, t => types_1.isArrayType(checker, t))) {
                // Array<T> -> T
                const typeArguments = types_1.getTypeArguments(checker, type);
                if (typeArguments.length > 0) {
                    type = typeArguments[0];
                }
            }
            if (types_1.isAnyType(type)) {
                context.report({
                    messageId: "anyViolation",
                    node: esNode,
                });
            }
        }
        return {
            BinaryExpression(esNode) {
                const tsNode = service.esTreeNodeToTSNodeMap.get(esNode);
                validateNotAnyType(esNode.left, tsNode.left);
                validateNotAnyType(esNode.right, tsNode.right);
            },
            UnaryExpression(esNode) {
                const tsNode = service.esTreeNodeToTSNodeMap.get(esNode);
                if (typescript_1.default.isPrefixUnaryExpression(tsNode) || typescript_1.default.isPostfixUnaryExpression(tsNode)) {
                    validateNotAnyType(esNode.argument, tsNode.operand);
                }
            },
            CallExpression(esNode) {
                validateNotAnyType(esNode.callee, service.esTreeNodeToTSNodeMap.get(esNode).expression);
            },
            NewExpression(esNode) {
                validateNotAnyType(esNode.callee, service.esTreeNodeToTSNodeMap.get(esNode).expression);
            },
            SpreadElement(esNode) {
                validateNotAnyType(esNode.argument, service.esTreeNodeToTSNodeMap.get(esNode).expression);
            },
            MemberExpression(esNode) {
                const tsNode = service.esTreeNodeToTSNodeMap.get(esNode);
                validateNotAnyType(esNode.object, tsNode.expression);
                if (typescript_1.default.isElementAccessExpression(tsNode)) {
                    validateNotAnyType(esNode.property, tsNode.argumentExpression);
                }
            },
        };
    },
});
